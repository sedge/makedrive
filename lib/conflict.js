/**
 * Utility functions for working with Conflicted Files.
 */
var Filer = require('./filer.js');
var Path = Filer.Path;
var constants = require('./constants.js');
var fsUtils = require('./fs-utils.js');

// Turn "/index.html" into "/index.html (Conflicted Copy 2014-07-23 12:00:00).html"
function generateConflictedPath(fs, path, callback) {
  var dirname = Path.dirname(path);
  var basename = Path.basename(path);
  var extname = Path.extname(path);

  var now = new Date();
  var dateStamp = now.getFullYear() + '-' +
        now.getMonth() + '-' +
        now.getDay() + ' ' +
        now.getHours() + ':' +
        now.getMinutes() + ':' +
        now.getSeconds();
  var conflictedCopy = ' (Conflicted Copy ' + dateStamp + ')';
  var conflictedPath = Path.join(dirname, basename + conflictedCopy + extname);

  // Copy the file using the conflicted filename. If there is
  // already a conflicted file, replace it with this one.
  fsUtils.forceCopy(fs, path, conflictedPath, function(err) {
    if(err) {
      return callback(err);
    }

    // Send the new path back on the callback
    callback(null, conflictedPath);
  });
}

function filenameContainsConflicted(path) {
  // Look for path to be a conflicted copy, e.g.,
  // /dir/index (Conflicted Copy 2014-07-23 12:00:00).html
  return /\(Conflicted Copy \d{4}-\d{1,2}-\d{1,2} \d{1,2}:\d{1,2}:\d{1,2}\)/.test(path);
}

function isConflictedCopy(fs, path, callback) {
  fs.getxattr(path, constants.attributes.conflict, function(err, value) {
    if(err && err.code !== 'ENOATTR') {
      return callback(err);
    }

    callback(null, !!value);
  });
}

function makeConflictedCopy(fs, path, callback) {
  fs.lstat(path, function(err, stats) {
    if(err) {
      return callback(err);
    }

    // If this is a dir, err now
    if(stats.isDirectory()) {
      return callback(new Filer.Errors.EPERM('conflicts not permitted on directories'));
    }

    // Otherwise, copy to a conflicted filename, and mark as makedrive-conflict
    generateConflictedPath(fs, path, function(err, conflictedPath) {
      if(err) {
        return callback(err);
      }
      fs.setxattr(conflictedPath, constants.attributes.conflict, true, function(err) {
        if(err) {
          return callback(err);
        }

        callback(null, conflictedPath);
      });
    });
  });
}

function removeFileConflict(fs, path, callback) {
  fs.removexattr(path, constants.attributes.conflict, function(err) {
    if(err && err.code !== 'ENOATTR') {
      return callback(err);
    }

    callback();
  });
}

module.exports = {
  filenameContainsConflicted: filenameContainsConflicted,
  isConflictedCopy: isConflictedCopy,
  makeConflictedCopy: makeConflictedCopy,
  removeFileConflict: removeFileConflict
};
